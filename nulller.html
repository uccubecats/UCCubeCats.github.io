<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Earth Globe</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #0d1b2a 0%, #000000 100%);
            font-family: 'Arial', sans-serif;
        }
        #canvas-container {
            width: 50%;
            height: 50%;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #info h2 {
            margin: 0 0 10px 0;
            font-size: 24px;
            color: #4fc3f7;
        }
        #info p {
            margin: 5px 0;
            font-size: 14px;
            color: #b0bec5;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            text-align: center;
        }
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #4fc3f7;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="loading" class="loading">
        <div class="spinner"></div>
        <p>Loading Earth...</p>
    </div>
    <div id="info">
        <h2>üåç Planet Earth</h2>
        <p>Drag to rotate | Scroll to zoom</p>
        <p>Right-click drag to pan</p>
    </div>

    <!-- Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Camera position
        camera.position.z = 3;

        // Create starfield background
        function createStarfield() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1.5,
                transparent: true,
                opacity: 0.8
            });

            const starsVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 2000;
                const y = (Math.random() - 0.5) * 2000;
                const z = (Math.random() - 0.5) * 2000;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }
        createStarfield();

        // Earth group
        const earthGroup = new THREE.Group();
        scene.add(earthGroup);

        // Create Earth
        const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
        
        // Load Earth textures
        const textureLoader = new THREE.TextureLoader();
        
        // Using NASA Blue Marble texture
        const earthTexture = textureLoader.load(
            'https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg',
            function() {
                // Texture loaded successfully
                document.getElementById('loading').style.display = 'none';
            },
            undefined,
            function() {
                // Fallback if texture fails to load
                earthMaterial.color.set(0x2233ff);
                document.getElementById('loading').style.display = 'none';
            }
        );

        const earthMaterial = new THREE.MeshPhongMaterial({
            map: earthTexture,
            shininess: 15,
            specular: 0x333333
        });

        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earthGroup.add(earth);

        // Create atmosphere glow
        const atmosphereGeometry = new THREE.SphereGeometry(1.05, 64, 64);
        const atmosphereMaterial = new THREE.MeshPhongMaterial({
            color: 0x4488ff,
            transparent: true,
            opacity: 0.2,
            side: THREE.BackSide
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        earthGroup.add(atmosphere);

        // Create outer glow
        const glowGeometry = new THREE.SphereGeometry(1.15, 64, 64);
        const glowMaterial = new THREE.ShaderMaterial({
            uniforms: {
                c: { type: "f", value: 0.3 },
                p: { type: "f", value: 4.5 },
                glowColor: { type: "c", value: new THREE.Color(0x4488ff) },
                viewVector: { type: "v3", value: camera.position }
            },
            vertexShader: `
                uniform vec3 viewVector;
                uniform float c;
                uniform float p;
                varying float intensity;
                void main() {
                    vec3 vNormal = normalize(normalMatrix * normal);
                    vec3 vNormel = normalize(normalMatrix * viewVector);
                    intensity = pow(c - dot(vNormal, vNormel), p);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 glowColor;
                varying float intensity;
                void main() {
                    vec3 glow = glowColor * intensity;
                    gl_FragColor = vec4(glow, 1.0);
                }
            `,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            transparent: true
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        earthGroup.add(glow);

        // Clouds layer (optional)
        const cloudsGeometry = new THREE.SphereGeometry(1.01, 64, 64);
        const cloudsMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const clouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
        earthGroup.add(clouds);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x333333);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(5, 3, 5);
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0x4488ff, 0.3);
        fillLight.position.set(-5, 0, -5);
        scene.add(fillLight);

        // Add subtle point lights
        const pointLight1 = new THREE.PointLight(0xffffff, 0.3);
        pointLight1.position.set(3, 0, 3);
        scene.add(pointLight1);

        // OrbitControls for interaction
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.minDistance = 1.5;
        controls.maxDistance = 10;
        controls.enablePan = true;

        // Animation variables
        let time = 0;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            time += 0.001;
            
            // Rotate Earth
            earth.rotation.y += 0.001;
            
            // Rotate clouds slightly faster
            clouds.rotation.y += 0.0012;
            
            // Subtle wobble animation
            earthGroup.rotation.x = Math.sin(time * 0.3) * 0.02;
            
            // Update glow shader
            glowMaterial.uniforms.viewVector.value = new THREE.Vector3().subVectors(
                camera.position,
                earthGroup.position
            );
            
            controls.update();
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Keyboard controls
        window.addEventListener('keydown', (e) => {
            if (e.key === ' ') {
                controls.autoRotate = !controls.autoRotate;
            }
            if (e.key === 'r' || e.key === 'R') {
                camera.position.set(0, 0, 3);
                controls.reset();
            }
        });

        // Start animation
        animate();

        // Hide loading after a short delay if texture doesn't trigger it
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
        }, 3000);
    </script>
</body>
</html>